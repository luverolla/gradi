# SDD - Software Design Document

This document illustrates what is the ides behind the GRADI software
and how it has been implemented

## The idea

GRADI is the short for _**GR**ande **A**rchivio **DI**gitale_, 
that, in italian language, means literally _great digital archive_.

The idea was to give companies, schools, or other kind of communities,
a way to store, edit and consult digital resources, regardless of their kind.
They can be general resources, such as books, movies or songs; but also,
more specific resources, such as medical records, degree theses or products in a stock.

For that, the system has to store information about resource types
and change them dynamically, in order to adapt to all future needs.

On the user side, I thought that there may be users at different levels,
with read or write permissions only on certain resources, groups
of resources, or resource types.

There is also a special user: the administrator (admin). It has full permissions
of everything belonging to the system, and it's the only one able to create, edit
or delete information about users and resource types.

## Entities

The idea described above has been implemented relaying on the following data structures.
These are used for both Java entity classes and database entity tables.

For each entity, apart from their own properties, the system stores two timestamps:
`createdAt` and `updatedAt`, that tells respectively, when the object has been created
and the last time it has been updated. 

All timestamps are represented with their timezone, indicated as offset from UTC.

### User

This entity represent the user who access the GRADI software to administer, edit or
just consult resources. Its properties are:
* `code`: unique for each object
* `name`: first name(s)
* `surname`: last name
* `email`: email address
* `password`: access password
* `description`: some details (not really used)
* `role`: represent level of authorizations, can be:
  * `USER`: has permission to consult resources
  * `EDITOR`: has permission to consult resources and create its own
  * `ADMIN`: system's administrator, has full permissions on everything

Code is automatically generated by system, and once created cannot be updated.
Since password are stored with encryption, cannot be directly modified, instead,
a new one is sent on users' request.

### Resource

This entity represent a digital resource stored on GRADI system. Its properties are:

* `code`: unique for each object
* `name`: mnemonic name
* `type`: resource type, defined custom properties
* `description`: some information
* `parent`: resource logically designed as parent (such as "collection" for "book")
* `visibility`: combined with [ResourcePermission](#resourcepermission) objects, grants
   or deny access permission to certain users, can be:
  * `PUBLIC`: like `INTERNAL`, but also non-registered user can consult
  * `INTERNAL` all registered users can consult, all editors can edit
    individual resource permissions are ignored.
  * `RESTRICTED` access permissions are defined by [ResourcePermission](#resourcepermission)
    objects

Code is automatically generated by system, and once created cannot be updated.
Since type brings along custom properties' information, once set, cannot be updated.

### ResourcePermission

This entity represent a permission that a certain user has on a certain resource.
Is composed by the following properties:
* `index`: unique progressive index, used as database table ID
* `user`: the user who has permission
* `resource`: the resource on which the permission applies
* `type`: represent the permission's level, can be:
  * `READ`: read-only permission
  * `WRITE`: read and write permission
  * `FULL`: same as `WRITE` but assigned only to the author user to identify it

When a user issues a request to update resource's permission, all existing permissions
are deleted, and new permission are created. The `FULL` permission is always preserved.

### ResourceType

This entity represent a type of resource, at which a set of properties belongs.
Its properties are:
* `code`: unique code for each object
* `name`: mnemonic name
* `brief`: brief plain text description
* `description`: full description (intended for HTML text)

Code is automatically generated by system, and once created cannot be updated.
The brief description is intended to be used in dropdown menus (like HTML `select`) to show some details.

### ResourceProperty

This entity represents a custom property belonging to a [ResourceType](#resourcetype).
Its properties are:
* `name`: unique name for each object
* `resourceType`: resource type at which the property belongs
* `type`: data type, can be
  * `STRING`: one-line plain text string
  * `TEXT`: formatted text (like HTML)
  * `NUMERIC`: real numbers, relies on the Java type `Double`
  * `DATETIME`: timestamps with time zone, relies on the Java type `OffsetDateTime`
  * `FIXED`: short string values in a certain set, like values that come out from dropdown menus
  * `RESOURCE`: resource's URIs, for internal referencing

When a user requests to add a resource property, it provides a alphanumeric space-free name.
Then, the server prepends to this name, the resource type's code and a pound sign (`#`).
So, for example, if user provides the property `author` to the resource type with code `04A8C13F90`,
the generated property's name will be: `04A8C13F90#author`.

Since the resource type represents vital information for the resource property, 
once set, it cannot be modified.

### ResourceAttribute

This entity represents a custom attribute of a resource.
Its properties are:
* `name`: unique name for each object
* `resourceProperty`: related custom property
* `resource`: resource at which attribute belongs
* `value`: attribute's value, with correct data type (imposed by property)

When a user requests to add a resource attribute, it provides the related property's name.
Then, the server prepends to this name, the resource's code and a pound sign (`#`).
So, for example, if user wants to set the property `author` to the resource with code `01A778BF45`,
the generated attribute's name will be: `01A778BF45#author`.

### ResourceFile

This entity represent a file attached to a resource.
Its properties are:
* `code`: unique code for each object
* `name`: filename with extension
* `resource`: resource at which the file belongs

The system automatically sets the file's name as its code plus the extension.

## Coding system

To ensure non-ambiguous identification, various systems are used among entities:

| Field   | Description                                                                        | Formula                   |
|---------|------------------------------------------------------------------------------------|---------------------------|
| `code`  | value of current timestamp translated to the year 2000, encoded in a base36 system | `currTime() - YEAR_2000`  |
| `name`  | full name as combination of other entity's code and pure name                      | `{entityCode}#{pureName}` |
| `index` | auto-incremented database index                                                    | N/A                       |

The `YEAR_2000` is the timestamp UNIX, in milliseconds, of the date: `2000-01-01T00:00:00+00:00`.
The base36 system extends hexadecimal system, by adding the other latin letters.

All entities using `code` as unique index are subclass of `CodedEntity`.
Unique indexes are automatically set by the system, and, eventual 
user-provided values for such fields are ignored.

## Security

### Authentication

Authentication is performed through a basic username/password system, with
the email acting as username. All passwords are stored encoded with BCrypt.

Once successfully logged in, a JWT token is provided to the client application.
It must be set as request header and expires after a given time.
These two information are sent as response after authentication, together with the token,
and can be changed by the administrator, via the `application.properties` file.

### Authorization

The JWT token stores information about the user, such as its role. So, the
system can always know if the authenticated user has permission to access certain resources.
If it isn't the case, a `403 Forbidden` error is sent back as response.

## Data manipulation

The GRADI system performs some data manipulation according to client request.
This is done via three operations: paging, filtering and sorting, and,
the client can adjust request parameter via an `EntitySetRequest` object.

### Paging

Paging system relies entirely on the JPA `PagingAndSortingRepository` interface,
and is executed according to the `page` and `limit` parameters of the request object.
Both parameters are integer numbers, and are required to perform a correct request.

The `page` parameter is zero-based (as indices in almost any programming language),
and tells what "group" of objects the client want to retrieve. The size of this "group"
is exactly the value of the `limit` parameter.

So, given such parameters, the client will retrieve data in the zero-based
range `[page*limit, (page+1)*limit[`. Note that the lower bound is included,
while the upper bound is excluded.

Data is sent even if it fills only a part of such range. While, if parameters
are malformed or range goes over available data, a `404 Not Found` error may be sent.

### Filtering

Filtering is done according to the `filter` parameter of the request object.
This is a map, and each entry contains the name of the property the client wants to filter by,
and an auxiliary value that may be used as "reference value".

For each entry, the property name is mapped to a filter class, and then,
result of individual filters are chained together.

The parameter to filter by can also be a resource custom property's name.
The server checks if this property exists, and if not, send an error back.

According to the property's type, "reference value" and filtering routines change:

| Type                | Filter condition    | Reference value         | Reference value type   |
|---------------------|---------------------|-------------------------|------------------------|
| `STRING`, `TEXT`    | includes substring? | substring               | `String`               |
| `NUMERIC`           | is in range?        | list of two bounds      | `List<Double>`         |
| `DATETIME`          | is in range?        | list of two bounds      | `List<OffsetDateTime>` |
| `FIXED`, `RESOURCE` | is one of list?     | list of possible values | `List<String>`         |

For the `TEXT` type, automatic HTML parsing is performed before filtering.
Properties with type `STRING` are considered plain-text.

For the lists of bounds, indicated as `[b1, b2]`, the following rules apply:
* both `null`: undefined behaviour
* only first `null`: condition is `value <= b2`
* only second `null`: condition is `value >= b1`
* both non-null: condition is `value >= b1 && value <= b2`

### Sorting

Sorting is done according to the `orders` parameter of the request object.
This is a map, and each entry contains the name of the property the client wants to sort by,
and the sorting way, that can be `asc` or `desc`. If an invalid string is provided, the system
automatically converts it to `asc`.

Each map's entry has the property mapped with a `Comparator` class. In case of descending
way, the `reverse()` method is applied. Individual results are then chained together.
Order of map's entries here is important, since it decides how the data will be sorted to the client.

For string-like properties, case-insensitive lexicographic sorting is performed.
Numbers and timestamps are naturally sorted.

For the `TEXT` type, automatic HTML parsing is performed before filtering.
Properties with type `STRING` are considered plain-text.
